import numpy as np 
import pygmsh 


def extract_boundary_points_from_mesh(mesh):
    """
    Extract the actual boundary points from the mesh generated by pygmsh.
    These represent the discretized B-spline boundary, not the control points.
    
    Parameters:
    mesh: pygmsh mesh object
    
    Returns:
    boundary_points: list of (x, y) tuples representing the actual boundary
    """
    boundary_points = []
    
    # Get boundary edges from mesh
    for cell in mesh.cells:
        if cell.type == "line":
            # These are the boundary edges
            for edge_indices in cell.data:
                if len(edge_indices) >= 2:
                    p1 = mesh.points[edge_indices[0]]
                    p2 = mesh.points[edge_indices[1]]
                    boundary_points.append((p1[0], p1[1]))
                    boundary_points.append((p2[0], p2[1]))
    
    # Remove duplicates while preserving order
    seen = set()
    unique_boundary_points = []
    for point in boundary_points:
        if point not in seen:
            seen.add(point)
            unique_boundary_points.append(point)
    
    return unique_boundary_points


def compute_upper_bound_cross_section(velocities):
    if velocities.size == 0:
        return 0.0

    v_mean = velocities.mean(axis= 0)
    delta_v = np.linalg.norm(velocities - v_mean, axis=1).max()
    return 2.0 * delta_v

def Iround(x):
    """
    Vectorized probabilistic rounding of an array of floats.

    Parameters:
        x (np.ndarray): Input array.

    Returns:
        np.ndarray: Array of rounded integers.
    """
    lower = np.floor(x).astype(int)
    prob = x - lower
    random_numbers = np.random.rand(*x.shape)
    return lower + np.where(random_numbers < prob, 1, 0)

def sample_particle_indices_to_collide_grid(Nc, cell_velocities, rng=None):
    """
    Generalized version for 2-D (and N-D) grids.

    Parameters
    ----------
    Nc : array-like of int, shape = grid shape (e.g., (nx, ny))
        Nc[idx] is the number of collision pairs to draw in that cell.
    cell_velocities : array-like, shape = grid shape + (object,)
        Each cell entry cell_velocities[idx] must be a 1-D array-like
        of per-particle velocities for that cell (length = #particles).
        Works well if this is a numpy array with dtype=object, or a nested list.
    rng : None | np.random.Generator | int
        Random generator or seed.

    Returns
    -------
    sampled_indices : np.ndarray(dtype=object, shape=Nc.shape)
        sampled_indices[idx] is a 1-D int array of length 2*Nc[idx]
        (empty array if Nc[idx] == 0).
    """
    Nc = np.asarray(Nc, dtype=int)
    grid_shape = Nc.shape

    # Basic shape check: the first Nc.ndim axes must match
    if tuple(np.shape(cell_velocities)[:Nc.ndim]) != grid_shape:
        raise ValueError(
            f"Shape mismatch: Nc.shape={grid_shape} vs cell_velocities.shape[:{Nc.ndim}]="
            f"{np.shape(cell_velocities)[:Nc.ndim]}"
        )

    # Robust RNG handling
    if isinstance(rng, (int, np.integer)) or rng is None:
        rng = np.random.default_rng(rng)

    sampled = np.empty(grid_shape, dtype=object)

    for idx in np.ndindex(*grid_shape):
        k = int(Nc[idx])
        if k < 0:
            raise ValueError(f"k must be nonnegative at cell {idx}, got {k}")

        # Get the per-cell particle list; ensure it's an array
        g = np.asarray(cell_velocities[idx])
        n_particles = int(g.shape[0])

        if 2 * k > n_particles:
            raise ValueError(
                f"Cannot sample {2*k} from cell {idx} which has {n_particles} particles"
            )

        if k == 0:
            sampled[idx] = np.empty(0, dtype=int)
        else:
            sampled[idx] = rng.choice(n_particles, size=2 * k, replace=False).astype(int)

    return sampled


def ArraySigma_VHS(v):
    Constant = 1.0
    alpha = 1
    return Constant * np.power(v, alpha)